"use strict";
module.exports = function (Promise, PromiseArray, apiRejection, debug) {
    var util = require("./util");
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    Promise.prototype["break"] = Promise.prototype.cancel = function () {
        if (!debug.cancellation()) return this._warn("cancellation is disabled");

        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
            if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                    child._followee().cancel();
                } else {
                    child._cancelBranched();
                }
                break;
            }

            var parent = promise._cancellationParent;
            if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                    promise._followee().cancel();
                } else {
                    promise._cancelBranched();
                }
                break;
            } else {
                if (promise._isFollowing()) promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
            }
        }
    };

    Promise.prototype._branchHasCancelled = function () {
        this._branchesRemainingToCancel--;
    };

    Promise.prototype._enoughBranchesHaveCancelled = function () {
        return this._branchesRemainingToCancel === undefined ||
            this._branchesRemainingToCancel <= 0;
    };

    Promise.prototype._cancelBy = function (canceller) {
        if (canceller === this) {
            this._branchesRemainingToCancel = 0;
            this._invokeOnCancel();
            return true;
        } else {
            this._branchHasCancelled();
            if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
            }
        }
        return false;
    };

    Promise.prototype._cancelBranched = function () {
        if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
        }
    };

    Promise.prototype._cancel = function () {
        if (!this._isCancellable()) return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, undefined);
    };

    Promise.prototype._cancelPromises = function () {
        if (this._length() > 0) this._settlePromises();
    };

    Promise.prototype._unsetOnCancel = function () {
        this._onCancelField = undefined;
    };

    Promise.prototype._isCancellable = function () {
        return this.isPending() && !this._isCancelled();
    };

    Promise.prototype.isCancellable = function () {
        return this.isPending() && !this.isCancelled();
    };

    Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
            for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
        } else if (onCancelCallback !== undefined) {
            if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    if (e === errorObj) {
                        this._attachExtraTrace(e.e);
                        async.throwLater(e.e);
                    }
                }
            } else {
                onCancelCallback._resultCancelled(this);
            }
        }
    };

    Promise.prototype._invokeOnCancel = function () {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };

    Promise.prototype._invokeInternalOnCancel = function () {
        if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);
            this._unsetOnCancel();
        }
    };

    Promise.prototype._resultCancelled = function () {
        this.cancel();
    };

};


function resolvePromise(promise2, x, resolve, reject) {
    var then
    var thenCalledOrThrow = false

    if (promise2 === x) { // 对应标准2.3.1节
        return reject(new TypeError('Chaining cycle detected for promise!'))
    }

    if (x instanceof Promise) { // 对应标准2.3.2节
        // 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值的
        // 所以这里需要做一下处理，而不能一概的以为它会被一个“正常”的值resolve
        if (x.status === 'pending') {
            x.then(function (value) {
                resolvePromise(promise2, value, resolve, reject)
            }, reject)
        } else { // 但如果这个Promise的状态已经确定了，那么它肯定有一个“正常”的值，而不是一个thenable，所以这里直接取它的状态
            x.then(resolve, reject)
        }
        return
    }

    if ((x !== null) && ((typeof x === 'object') || (typeof x === 'function'))) { // 2.3.3
        try {

            // 2.3.3.1 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用
            // 即要判断它的类型，又要调用它，这就是两次读取
            then = x.then
            if (typeof then === 'function') { // 2.3.3.3
                then.call(x, function rs(y) { // 2.3.3.3.1
                    if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准
                    thenCalledOrThrow = true
                    return resolvePromise(promise2, y, resolve, reject) // 2.3.3.3.1
                }, function rj(r) { // 2.3.3.3.2
                    if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准
                    thenCalledOrThrow = true
                    return reject(r)
                })
            } else { // 2.3.3.4
                resolve(x)
            }
        } catch (e) { // 2.3.3.2
            if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准
            thenCalledOrThrow = true
            return reject(e)
        }
    } else { // 2.3.4
        resolve(x)
    }
}